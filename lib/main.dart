import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:test/color_bloc/color_bloc.dart';

import 'package:test/counter_bloc/counter_bloc.dart';
import 'package:test/counter_bloc/counter_event.dart';
import 'package:test/counter_bloc/counter_state.dart';

//blocprovider provides the bloc to its children
//blocbuilder rebuilds the ui based on the state
//bloclistener listens to diff states generated by the bloc
//(based on state we can show snackbar or dialog or navigate to diff pages)
//blocconsumer combines functionality of blocbuilder and bloclistener
//blocselector is used to filter widgets based on current state of bloc
//to use multiple blocs we can either nest blocproviders or use multiblocprovider

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider<CounterBloc>(
          //CounterBloc is the type of bloc
          create: (context) => CounterBloc(),
        ),
        BlocProvider<ColorBloc>(create: (context) => ColorBloc()),
      ],
      child: MaterialApp(
        title: 'Flutter Demo Bloc',
        theme: ThemeData(
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
          useMaterial3: true,
        ),
        home: const MyHomePage(title: 'Flutter Bloc Demo Home Page'),
      ),
    );
  }
}

class MyHomePage extends StatelessWidget {
  const MyHomePage({super.key, required this.title});
  // Fields in a Widget subclass are always marked "final".

  final String title;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(title),
      ),
      body: Stack(
        children: <Widget>[
          Align(
            alignment: Alignment.bottomLeft,
            child: Padding(
              padding: const EdgeInsets.all(10.0),
              child: FloatingActionButton(
                onPressed: () {
                  context.read<CounterBloc>().add(CounterDecrementEvent());
                },
                tooltip: 'Decrement',
                child: const Icon(Icons.remove),
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomRight,
            child: Padding(
              padding: const EdgeInsets.all(10.0),
              child: FloatingActionButton(
                onPressed: () {
                  context
                      .read<CounterBloc>()
                      .add(CounterIncrementEvent()); //to generate event
                },
                tooltip: 'Increment',
                child: const Icon(Icons.add),
              ),
            ),
          ),
          BlocSelector<CounterBloc, CounterState, bool>(
              selector: (state) => state.counter >= 3 ? true : false,
              builder: (context, state) {
                return Center(
                  child: Container(
                    width: 200,
                    height: 200,
                    color: state ? Colors.green : Colors.blue,
                  ),
                );
              }),
          Center(
            child: Column(
              // Column is also a layout widget. It takes a list of children and
              // arranges them vertically. By default, it sizes itself to fit its
              // children horizontally, and tries to be as tall as its parent.
              //
              // Column has various properties to control how it sizes itself and
              // how it positions its children. Here we use mainAxisAlignment to
              // center the children vertically; the main axis here is the vertical
              // axis because Columns are vertical (the cross axis would be
              // horizontal).
              //
              // TRY THIS: Invoke "debug painting" (choose the "Toggle Debug Paint"
              // action in the IDE, or press "p" in the console), to see the
              // wireframe for each widget.
              mainAxisAlignment: MainAxisAlignment.center,
              children: <Widget>[
                const Text(
                  'You have pushed the button this many times:',
                ),

                BlocConsumer<CounterBloc, CounterState>(
                    builder: (context, state) {
                  return Text('${state.counter}');
                }, listener: (context, state) {
                  if (state.counter >= 5) {
                    final snackBar = SnackBar(
                      elevation: 0,
                      behavior: SnackBarBehavior.floating,
                      backgroundColor: Color.fromARGB(206, 132, 206, 114),
                      content: Text("You have reached ${state.counter}."),
                    );
                    ScaffoldMessenger.of(context).showSnackBar(snackBar);
                  }
                }),

                // BlocListener<CounterBloc, CounterState>(
                //   listenWhen: (previous,current) => true,
                //   listener: (context, state) {
                //     if (state.counter >= 5) {
                //       final snackBar = SnackBar(
                //         elevation: 0,
                //         behavior: SnackBarBehavior.floating,
                //         backgroundColor: Color.fromARGB(206, 206, 114, 114),
                //         content: Text("You have reached ${state.counter}!!"),
                //       );
                //       ScaffoldMessenger.of(context).showSnackBar(snackBar);
                //     }
                //   },
                //   child: Text('Bloc Listener'),
                // ),

                // BlocBuilder<CounterBloc, CounterState>(
                //     buildWhen: (previous, current) {
                //   print(previous.counter); //prints previous and current states
                //   print(current.counter);
                //   return true; //ui is updated only when buildWhen is true
                //   // we can give conditions like return current.counter>=5 (so ui will be updated only when counter reaches 5)
                // }, builder: (context, state) {
                //   return Text(
                //     '${state.counter}',
                //     style: Theme.of(context).textTheme.headlineMedium,
                //   );
                // }),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
